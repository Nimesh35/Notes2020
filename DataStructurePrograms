1.

#include<stdio.h>

struct Student
{
	int rollno;
	char name[20];	
};

int main()
{
	struct Student s1;
	
	s1.rollno=101;
	strcpy(s1.name,"Saurabh");
	
	printf("Roll no : %d , Name : %s",s1.rollno,s1.name);	
}
==============================================================

2.

#include<stdio.h>

struct Student
{
	int rollno;
	char name[20];	
};

int main()
{
	struct Student *s1,s;
	s1=&s;
	s1->rollno=101;
	strcpy(s1->name,"Saurabh");
	
	printf("Roll no : %d , Name : %s",s1->rollno,s1->name);	
}

===============================================================

3.

#include<stdio.h>

struct Employee
{
	int eid;
	char name[20];
	char city[20];	
};

int main()
{
	struct Employee e[3];
	char nm[20];
	char cy[20];
	int i;
	for(i=0;i<3;i++)
	{
		printf("Enter Id : ");
		scanf("%d",&e[i].eid);
		
		fflush(stdin);	
		printf("Enter name :");
		gets(nm);
		strcpy(e[i].name,nm);
		
		fflush(stdin);
		printf("Enter City :");
		gets(cy);
		strcpy(e[i].city,cy);
		fflush(stdin);
	}
	
	for(i=0;i<3;i++)
	{
		printf("Id : %d , Name : %s , City : %s\n",e[i].eid,e[i].name,e[i].city);
	}
	
}
========================================================================

4.

#include<stdio.h>

int main()
{
	float num[]={1.2,1.3,1.4};
	float *p=num;
	
	int i;
	for(i=0;i<3;i++)
	{
		printf("%.2f\t",*(p+i));
	}
	
}
=========================================================================

5.

#include<stdio.h>

int main()
{
	int *p;
	
	p=(int*)malloc(sizeof(int));
	
	*p=400;
	
	printf("value : %d",*p);
	
	free(p);
}

==========================================================================

6.

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;


int main()
{
	int p;
	sample *sp;
	sample s;
	
	sp=&s;
	//sp=(sample*)malloc(sizeof(sample));  // create memory dynamically for structure
	
	if(sp==NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	sp->x='D';
	sp->y=300;
	
	printf("x = %c , y = %d",sp->x,sp->y);	
	
		
}
=====================================================================================

7. 

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;

void fun(sample *p);

int main()
{
	sample *sp;
	
	sp=(sample*)malloc(sizeof(sample));
	
	if(sp==NULL)
	{
		printf("Memory not available");
		exit(0);
	}
	
	fun(sp);   // Passing structure pointer to function
	
	printf("x = %c , y = %d",sp->x,sp->y);
	
	free(sp);
			
}

void fun(sample *p)     // sample *p = sp;
{
	p->x='G';
	p->y=200;
}

====================================================================

8.

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;

sample* fun();

int main()
{
	sample *sp;
		
	sp=fun();   // sp = p;
	
	printf("x = %c , y = %d",sp->x,sp->y);
	
	free(sp);
			
}

sample* fun()     // sample *p = sp;
{
	sample *p;
	
	p=(sample*)malloc(sizeof(sample));
	
	if(p==NULL)
	{
		printf("memory not available");
		exit(0);
	}
	
	p->x='G';
	p->y=300;
	
	return p;
}

==================================================================

9.

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;

void fun(sample *sp);

int main()
{
	sample s;
			
    s.x='D';
    s.y=400;
    
    printf("Before calling function values of x and y are : ");
    printf("x = %c , y = %d\n",s.x,s.y);
    fun(&s);   // Passing Address of structure variable to the function
    printf("After calling function values of x and y are : ");
    printf("x = %c , y = %d\n",s.x,s.y);
}

void fun(sample *sp)
{
	sp->x='H';
	sp->y=500;
}

==============================================================================

10.

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(sp->top == -1)
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	
	printf("Stack elements are : ");
	printf("%d %d %d",s1.elements[0],s1.elements[1],s1.elements[2]);
	
	printf("\n");
	push(&s1,40);
	printf("Stack elements are : ");
	printf("%d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3]);
	
	printf("\n");
	push(&s1,50);
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);

	printf("\n");
	push(&s1,60);
	printf("Stack elements are : ");
	printf("%d %d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4],s1.elements[5]);

	int ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	printf("\n");	
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);

	push(&s1,60);
	
	printf("\n");	
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);

	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	printf("\n");	
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
}

==================================================================================================

11.

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(sp->top == -1)
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}


void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	push(&s1,40);
		
	display(&s1);
	
	printf("\n");
	pop(&s1);
	//pop(&s1);
	display(&s1);

	printf("\n%d",s1.elements[3]);
}


===================================================================

12.

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	push(&s1,40);
	push(&s1,50);
	//push(&s1,60);
	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));
	display(&s1);

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);	
}


=================================================================

13

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of static allocation of stack in memory

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)       // sp = &s1
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	push(&s1,40);
	push(&s1,50);
	//push(&s1,60);
	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));
	display(&s1);

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);	
}

==============================================================================

14

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of static allocation of stack in memory

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)      // sp = s1  
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)    // sp = s1
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack *s1;
	
	s1=(stack*)malloc(sizeof(stack));  // Dynamic allocation of stack pointer
	
	if(s1 == NULL)
	{
		printf("Memory available");
		exit(0);	
	}
	
	initialize(s1);
	push(s1,10);
	push(s1,20);
	push(s1,30);
	push(s1,40);
	push(s1,50);
	//push(&s1,60);
	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));
	display(s1);

	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	

	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);	
}


=========================================================================

15

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of static allocation of stack in memory

typedef struct st
{
	int top;
	char elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)       // sp = &s1
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,char item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%c ",sp->elements[i]);	
	}	
}

int main()
{
	stack *s1;
	
	s1=(stack*)malloc(sizeof(stack));
	
	char *str;
	
	initialize(s1);
    
	//printf("Enter a string : ");
	//gets(str);
	
	
	char ch;
	printf("Enter character : ");
	scanf("%c",&ch);
	fflush(stdin);
	while((ch!='n'))
	{
		  	fflush(stdin);
		    push(s1,ch);
			printf("Enter character : ");
        	scanf("%c",&ch); 
	}
	
	
	int i=0;
	
	//while(*str!='\0')
	//{
		push(s1,'H');  // pushing character one by one on the stack
		push(s1,'e');
		push(s1,'l');
		push(s1,'l');
		push(s1,'o');
	
	/*	
		for(i=s1->top;i!=-1;i--)
		printf("%c",s1->elements[i]);
	*/	
		printf("\n");
		char x;
		while(!(is_empty(s1)))
		{
			x=pop(s1);
			printf("%c",x);
		}
	//	str++;
	//	i++;
	//}

	//printf("%c",s1.elements[0]);	
//	display(&s1);
			
}

============================================================================

16

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of Stack to revrse a string
typedef struct st
{
	int top;
	char elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)       // sp = &s1
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,char item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	/*for(i=sp->top;i!=-1;i--)
	{
		printf("%c ",sp->elements[i]);	
	}*/
	
	for(i=0;i<=sp->top;i++)
	{
		printf("%c ",sp->elements[i]);
	}	
}

int main()
{
	stack *s1;
	
	s1=(stack*)malloc(sizeof(stack));
	
	initialize(s1);

 /*	
	push(s1,'A');
	push(s1,'B');
	push(s1,'C');
*/
	
	char str[10];
	int size;
	printf("Enter no of characters of a string :");
	scanf("%d",&size);
	
    printf("Enter a string : ");
	
	int i;
	for(i=0;i<size;i++)
		scanf("%c",&str[i]);  // abc\0 
	
	i=0;
	while(str[i]!='\0')
	{
		push(s1,str[i]);
		i++;	
	}
		
	printf("Original stack : ");
	display(s1);
	
	printf("\n");
	
	printf("Stack in reverse order : ");
	char ch;
	while(!is_empty(s1))	
	{
		ch=pop(s1);
		printf("%c",ch);
	}
}


===================================================================

17

#include<stdio.h>
#include<stdlib.h>
#define SIZE 10

// Example of Stack to revrse a string
typedef struct que
{
	int front;
	int rear;
	int elements[SIZE];	
}Queue;

void initialize(Queue *qp)
{
	qp->front=-1;
	qp->rear=-1;	
}

void add(Queue *qp,int item)
{
	if(is_full(qp))
		printf("Queue Overflow");
	else
	{	
		if(qp->front == -1)
			qp->front=0;
		qp->elements[++qp->rear]=item;	
	}
	
}

int rem(Queue *qp)
{
	int x;
	if(is_empty())
		printf("Queue Underflow");
	else
	{
		if(qp->front>qp->rear)
			qp->front=qp->rear=-1;
			x=qp->elements[qp->front++];
	}
	
	return x;	
}

void display(Queue *qp)
{
	
		int i;
		for(i=qp->front;i<=qp->rear;i++)
		{
			printf("%d ",qp->elements[i]);	
		}	
	
}

int is_full(Queue *qp)
{
	if(qp->rear == SIZE-1)
		return 1;
	else
		return 0;
}

int is_empty(Queue *qp)
{
	if(qp->front == -1)
		return 1;
	else
		return 0;	
}

int main()
{
	Queue *qp;
	qp=(Queue*)malloc(sizeof(Queue));
	
	initialize(qp);
	
	add(qp,10);
	add(qp,20);
	add(qp,30);
	add(qp,40);
	add(qp,50);
	add(qp,60);
	
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);


	printf("\n");
	rem(qp);
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);	
	
	printf("\n");
	rem(qp);
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);
}

==========================================================================

18

#include<stdio.h>
#include<stdlib.h>
#define SIZE 10

typedef struct st
{
	int top;
	char name[10][10];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,char *name)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			strcpy(sp->name[++sp->top],name);
}

// Delete an element from the stack / POP operation

char* pop(stack *sp)
{
	char* x;
	if(sp->top == -1)
		printf("\nStack underflow");
	else
		x=sp->name[sp->top--];
	return x;	
}


void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%s\n",*(sp->name+i));	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,"Ajay");
	push(&s1,"Amit");
	push(&s1,"Rohit");
	
	display(&s1);
	
	printf("\n");
	char*p=pop(&s1);
	printf("Deleted name is : %s\n",p);
	display(&s1);
}

=============================================================================

19

#include<stdio.h>
#include<stdlib.h>
#define SIZE 26
#include "mystack.h"

int main()
{
	stack s1;
	
	initialize(&s1);
	
	int i;
	
	for(i=65;i<=90;i++)
	{
		push(&s1,i);
	}
	
	display(&s1);
}

==============================================================================

20

#include<stdio.h>

// Creation of a node & display the node value

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

int main()
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=500;
	np->next=NULL;
	
	printf("value : %d",np->data);
	
	free(np);	// Deallocating dynamic memory for node pointer
}

===============================================================================

21

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{
	
	node *p;	
	
	p=createNode(20);   // p = np
	
	printf("data : %d",p->data);
	printf("\nnext : %d",p->next);
	
	free(p);	// Deallocating dynamic memory for node pointer
}

==================================================================================

22

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{	
	node *p,*head,*tail,*ptr;	
	
	head=createNode(60);    // creation of first node
	tail=head;
	ptr=head;
	printf("%d ",ptr->data);  // ptr is priniting data value
	
	p=createNode(75);       // creation of second node
	
	tail->next=p;     // Attaching next node to previuous node   
    tail=tail->next;
    //ptr=tail;
	ptr=ptr->next;
	printf("%d ",ptr->data);
 	
    p=createNode(150);      // creation of third node
    
	tail->next=p;      // Attaching next node to previuous node   
	tail=tail->next;
	//ptr=tail;
	ptr=ptr->next;
	printf("%d ",ptr->data);
	
}

============================================================================

23

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{	
	node *p,*head,*tail,*ptr;	
	
	head=createNode(60);    // creation of first node
	tail=head;
	p=createNode(75);       // creation of second node
	
	tail->next=p;     // Attaching next node to previuous node   
    tail=tail->next;
   
    p=createNode(150);      // creation of third node
    
	tail->next=p;      // Attaching next node to previuous node   
	tail=tail->next;
	
	ptr=head;
	
	// accessing of node value using while loop
	while(ptr!=NULL)
	{
		printf("%d\t",ptr->data);
		ptr=ptr->next;
	}

}

====================================================================

24

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	double data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;


void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

node* createNode(double no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}


void insertAtTail(List *lp,double x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}

List* createList(int size)
{
	List *lp;
	lp=(List*)malloc(sizeof(List));
		initialize(lp);
	int i;
	double x;
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%lf",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

void traverse(List *lp)
{
	node *p;
	p=lp->head;
	int c=0;
	double sum=0.0,avg;
	printf("List is : ");
	
	while(p!=NULL)
	{
		printf("%.2lf ",p->data);
		sum=sum+(p->data);
		p=p->next;
		c++;	
	}	
	avg=sum/c;
	printf("\nAverage : %.2lf",avg);
}

int getNodeCount(List *lp)
{
	node *p;
	
	int count=0;
	
	for(p=lp->head;p!=NULL;p=p->next)
	{
		++count;	
	}	
	return count;
}

int main()
{	
	List *lp;
	int x;
	
	lp=createList(5);
	traverse(lp);
	
	
}

====================================================================

25

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;


void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}


void insertAtTail(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}

List* createList(int size)
{
	List *lp;
	lp=(List*)malloc(sizeof(List));
		initialize(lp);
	int i;
	int x;
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%d",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

void traverse(List *lp)
{
	node *p;
	p=lp->head;
	printf("List is : ");
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;	
	}	
}

int getNodeCount(List *lp)
{
	node *p;
	
	int count=0;
	
	for(p=lp->head;p!=NULL;p=p->next)
	{
		++count;	
	}	
	return count;
}

int main()
{	
	List *lp;
	int x;
	
	lp=createList(5);
	traverse(lp);
	
	int count=getNodeCount(lp);
	
	printf("\nTotal nodes : %d",count);	

}

=============================================================

26

// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;

// Initialization of Head and Tail pointer to NULL
void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

// Creating a node of Linked list
node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

// Inserting a node at the end of list
void insertAtTail(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}


void insertAtHead(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->tail=np;
	else
		np->next=lp->head;
	lp->head= np;
	
}
// Creating a list of specified size
List* createList()   // Creating a list of a specific size
{
	List *lp;
	int i,x,size;
	
	lp=(List*)malloc(sizeof(List));
	initialize(lp);
		
	printf("Enter no of elements : ");
	scanf("%d",&size);
	
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%d",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

// To display list elements
void traverse(List *lp)
{
	node *p;
	p=lp->head;
	printf("List is : ");
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;	
	}	
}


#include<stdio.h>
#include<stdlib.h>
#include "mylinklist.h"

int main()
{	
	List *lp;         // lp is List pointer 
	
	// Step-1 : Link list Creation
	lp=createList();  // lp will point to the created list
	
	// Step-2 : Displaying the List
	traverse(lp);  
	
	printf("\n");
	
	int item;
	printf("\nEnter node to add at head :");
	scanf("%d",&item);
	
	insertAtHead(lp,item);   
	//insertAtHead(lp,400);   
	traverse(lp); 
}

====================================================================

27

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;                // Data part
	struct nd *next;         // Pointer to next node
	struct nd *prev;         // Pointer to previous node
}node;
// Creating a node in the linked list

int main()
{	
	 node *head;
	 node *one=NULL;
	 node *two=NULL;
	 node *three=NULL;
	
	one=(node*)malloc(sizeof(node));    // data / next for node one
	two=(node*)malloc(sizeof(node));     // data / next for node two
	three=(node*)malloc(sizeof(node));   // data / next for node three
	
	one->data=10;
	two->data=20;
	three->data=30;
	
	one->next=two;
	one->prev=NULL;
	
	two->next=three;
	two->prev=one;
	
	three->next=NULL;
	three->prev=two;
	
	head=one;
	
	node *p;
	p=head;

	printf("Accessing in forward direction : ");
	/*
	printf("%d ",p->data);
	p=p->next;
	
	printf("%d ",p->data);
	p=p->next;
	
	printf("%d ",p->data);
	p=p->next;
	*/
	
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;
	}
	printf("\nAccessing in backward direction : ");
	
	/*
	p=three;
	printf("%d ",p->data);
	p=p->prev;
	
	printf("%d ",p->data);
	p=p->prev;
	
	printf("%d ",p->data);
	p=p->prev;
	*/
	p=three;
	
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->prev;
	}
}

===========================================================================

28

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of Stack to revrse a string
typedef struct st1
{
	int top;
	char elements[SIZE];	
}stack1;

typedef struct st2
{
	int top;
	char elements[SIZE];	
}stack2;

// Initiazation of stack, top = -1

void initialize(stack1 *sp1,stack2 *sp2)       // sp = &s1
{
	sp1->top=-1;
	sp2->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void pushToStack1(stack1 *sp,char item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}


void pushToStack2(stack2 *sp,char item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}
// Delete an element from the stack / POP operation

void copyToStack(stack1 *s1,stack2 *s2)
{
	int i;
	
	for(i=0;i<=s1->top;i++)
	{
		printf("%c ",s1->elements[i]);
		pushToStack2(s2,s1->elements[i]);	
	}	
}

void displayCopiedStack(stack2 *s)
{
	int i;
	for(i=0;i<=s->top;i++)
	{
		printf("%c ",s->elements[i]);	
	}	
}

int main()
{
	stack1 *s1;
	stack2 *s2;
	
	s1=(stack1*)malloc(sizeof(stack1));
	s2=(stack2*)malloc(sizeof(stack2));
	
	initialize(s1,s2);
		
	printf("==========================================\n");
	printf("Stack : 1 \n==============================\n");
	
	pushToStack1(s1,'A');
	pushToStack1(s1,'B');
	pushToStack1(s1,'C');
	pushToStack1(s1,'D');
		
	copyToStack(s1,s2);
	
	printf("\n========================================\n");
	printf("Stack : 2 \n==============================\n");
	displayCopiedStack(s2);
}


===============================================================================================

29

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{	
	 node *head;
	 node *one=NULL;
	 node *two=NULL;
	 node *three=NULL;
	
	one=(node*)malloc(sizeof(node));    // data / next for node one
	two=(node*)malloc(sizeof(node));     // data / next for node two
	three=(node*)malloc(sizeof(node));   // data / next for node three
	
	one->data=10;
	two->data=20;
	three->data=30;
	
	one->next=two;
	two->next=three;
	three->next=one;
	
	head=one;
	
	node *p;
	p=head;
	printf("%d ",p->data);
		p=p->next;
	while(p!=head)
	{
		printf("%d ",p->data);
		p=p->next;
	}
}




