1.

#include<stdio.h>

struct Student
{
	int rollno;
	char name[20];	
};

int main()
{
	struct Student s1;
	
	s1.rollno=101;
	strcpy(s1.name,"Saurabh");
	
	printf("Roll no : %d , Name : %s",s1.rollno,s1.name);	
}
==============================================================

2.

#include<stdio.h>

struct Student
{
	int rollno;
	char name[20];	
};

int main()
{
	struct Student *s1,s;
	s1=&s;
	s1->rollno=101;
	strcpy(s1->name,"Saurabh");
	
	printf("Roll no : %d , Name : %s",s1->rollno,s1->name);	
}

===============================================================

3.

#include<stdio.h>

struct Employee
{
	int eid;
	char name[20];
	char city[20];	
};

int main()
{
	struct Employee e[3];
	char nm[20];
	char cy[20];
	int i;
	for(i=0;i<3;i++)
	{
		printf("Enter Id : ");
		scanf("%d",&e[i].eid);
		
		fflush(stdin);	
		printf("Enter name :");
		gets(nm);
		strcpy(e[i].name,nm);
		
		fflush(stdin);
		printf("Enter City :");
		gets(cy);
		strcpy(e[i].city,cy);
		fflush(stdin);
	}
	
	for(i=0;i<3;i++)
	{
		printf("Id : %d , Name : %s , City : %s\n",e[i].eid,e[i].name,e[i].city);
	}
	
}
========================================================================

4.

#include<stdio.h>

int main()
{
	float num[]={1.2,1.3,1.4};
	float *p=num;
	
	int i;
	for(i=0;i<3;i++)
	{
		printf("%.2f\t",*(p+i));
	}
	
}
=========================================================================

5.

#include<stdio.h>

int main()
{
	int *p;
	
	p=(int*)malloc(sizeof(int));
	
	*p=400;
	
	printf("value : %d",*p);
	
	free(p);
}

==========================================================================

6.

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;


int main()
{
	int p;
	sample *sp;
	sample s;
	
	sp=&s;
	//sp=(sample*)malloc(sizeof(sample));  // create memory dynamically for structure
	
	if(sp==NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	sp->x='D';
	sp->y=300;
	
	printf("x = %c , y = %d",sp->x,sp->y);	
	
		
}
=====================================================================================

7. 

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;

void fun(sample *p);

int main()
{
	sample *sp;
	
	sp=(sample*)malloc(sizeof(sample));
	
	if(sp==NULL)
	{
		printf("Memory not available");
		exit(0);
	}
	
	fun(sp);   // Passing structure pointer to function
	
	printf("x = %c , y = %d",sp->x,sp->y);
	
	free(sp);
			
}

void fun(sample *p)     // sample *p = sp;
{
	p->x='G';
	p->y=200;
}

====================================================================

8.

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;

sample* fun();

int main()
{
	sample *sp;
		
	sp=fun();   // sp = p;
	
	printf("x = %c , y = %d",sp->x,sp->y);
	
	free(sp);
			
}

sample* fun()     // sample *p = sp;
{
	sample *p;
	
	p=(sample*)malloc(sizeof(sample));
	
	if(p==NULL)
	{
		printf("memory not available");
		exit(0);
	}
	
	p->x='G';
	p->y=300;
	
	return p;
}

==================================================================

9.

#include<stdio.h>
#include<stdlib.h>

typedef struct st
{
		char x;
		int y;
}sample;

void fun(sample *sp);

int main()
{
	sample s;
			
    s.x='D';
    s.y=400;
    
    printf("Before calling function values of x and y are : ");
    printf("x = %c , y = %d\n",s.x,s.y);
    fun(&s);   // Passing Address of structure variable to the function
    printf("After calling function values of x and y are : ");
    printf("x = %c , y = %d\n",s.x,s.y);
}

void fun(sample *sp)
{
	sp->x='H';
	sp->y=500;
}

==============================================================================

10.

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(sp->top == -1)
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	
	printf("Stack elements are : ");
	printf("%d %d %d",s1.elements[0],s1.elements[1],s1.elements[2]);
	
	printf("\n");
	push(&s1,40);
	printf("Stack elements are : ");
	printf("%d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3]);
	
	printf("\n");
	push(&s1,50);
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);

	printf("\n");
	push(&s1,60);
	printf("Stack elements are : ");
	printf("%d %d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4],s1.elements[5]);

	int ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	printf("\n");	
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);

	push(&s1,60);
	
	printf("\n");	
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);

	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	printf("\n");	
	printf("Stack elements are : ");
	printf("%d %d %d %d %d",s1.elements[0],s1.elements[1],s1.elements[2],s1.elements[3],s1.elements[4]);
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
	
	ele=pop(&s1); // Delete operation
	printf("\nPopped element is : %d",ele);
}

==================================================================================================

11.

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(sp->top == -1)
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}


void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	push(&s1,40);
		
	display(&s1);
	
	printf("\n");
	pop(&s1);
	//pop(&s1);
	display(&s1);

	printf("\n%d",s1.elements[3]);
}


===================================================================

12.

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	push(&s1,40);
	push(&s1,50);
	//push(&s1,60);
	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));
	display(&s1);

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);	
}


=================================================================

13

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of static allocation of stack in memory

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)       // sp = &s1
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,10);
	push(&s1,20);
	push(&s1,30);
	push(&s1,40);
	push(&s1,50);
	//push(&s1,60);
	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));
	display(&s1);

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	

	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);
	
	printf("\nPopped element is : %d\n",pop(&s1));	
	display(&s1);	
}

==============================================================================

14

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of static allocation of stack in memory

typedef struct st
{
	int top;
	int elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)      // sp = s1  
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,int item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)    // sp = s1
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%d ",sp->elements[i]);	
	}	
}

int main()
{
	stack *s1;
	
	s1=(stack*)malloc(sizeof(stack));  // Dynamic allocation of stack pointer
	
	if(s1 == NULL)
	{
		printf("Memory available");
		exit(0);	
	}
	
	initialize(s1);
	push(s1,10);
	push(s1,20);
	push(s1,30);
	push(s1,40);
	push(s1,50);
	//push(&s1,60);
	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));
	display(s1);

	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	

	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);
	
	printf("\nPopped element is : %d\n",pop(s1));	
	display(s1);	
}


=========================================================================

15

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of static allocation of stack in memory

typedef struct st
{
	int top;
	char elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)       // sp = &s1
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,char item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%c ",sp->elements[i]);	
	}	
}

int main()
{
	stack *s1;
	
	s1=(stack*)malloc(sizeof(stack));
	
	char *str;
	
	initialize(s1);
    
	//printf("Enter a string : ");
	//gets(str);
	
	
	char ch;
	printf("Enter character : ");
	scanf("%c",&ch);
	fflush(stdin);
	while((ch!='n'))
	{
		  	fflush(stdin);
		    push(s1,ch);
			printf("Enter character : ");
        	scanf("%c",&ch); 
	}
	
	
	int i=0;
	
	//while(*str!='\0')
	//{
		push(s1,'H');  // pushing character one by one on the stack
		push(s1,'e');
		push(s1,'l');
		push(s1,'l');
		push(s1,'o');
	
	/*	
		for(i=s1->top;i!=-1;i--)
		printf("%c",s1->elements[i]);
	*/	
		printf("\n");
		char x;
		while(!(is_empty(s1)))
		{
			x=pop(s1);
			printf("%c",x);
		}
	//	str++;
	//	i++;
	//}

	//printf("%c",s1.elements[0]);	
//	display(&s1);
			
}

============================================================================

16

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of Stack to revrse a string
typedef struct st
{
	int top;
	char elements[SIZE];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)       // sp = &s1
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,char item)
{
		if(is_full(sp))	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}

// Delete an element from the stack / POP operation

int pop(stack *sp)
{
	int x;
	if(is_empty(sp))
		printf("\nStack underflow");
	else
		x=sp->elements[sp->top--];
	return x;	
}

int is_full(stack *sp)   // returning 1 if stack is full otherwise returns 0
{
	if(sp->top == SIZE-1)      // Stack overflow condition
		return 1;
	else
		return 0;
}

int is_empty(stack *sp)   // returning 1 if stack is empty otherwise returns 0
{
	if(sp->top == -1)          // Stack underflow condition
		return 1;
	else
		return 0;	
}

void display(stack *sp)
{
	int i;
	
	/*for(i=sp->top;i!=-1;i--)
	{
		printf("%c ",sp->elements[i]);	
	}*/
	
	for(i=0;i<=sp->top;i++)
	{
		printf("%c ",sp->elements[i]);
	}	
}

int main()
{
	stack *s1;
	
	s1=(stack*)malloc(sizeof(stack));
	
	initialize(s1);

 /*	
	push(s1,'A');
	push(s1,'B');
	push(s1,'C');
*/
	
	char str[10];
	int size;
	printf("Enter no of characters of a string :");
	scanf("%d",&size);
	
    printf("Enter a string : ");
	
	int i;
	for(i=0;i<size;i++)
		scanf("%c",&str[i]);  // abc\0 
	
	i=0;
	while(str[i]!='\0')
	{
		push(s1,str[i]);
		i++;	
	}
		
	printf("Original stack : ");
	display(s1);
	
	printf("\n");
	
	printf("Stack in reverse order : ");
	char ch;
	while(!is_empty(s1))	
	{
		ch=pop(s1);
		printf("%c",ch);
	}
}


===================================================================

17

#include<stdio.h>
#include<stdlib.h>
#define SIZE 10

// Example of Stack to revrse a string
typedef struct que
{
	int front;
	int rear;
	int elements[SIZE];	
}Queue;

void initialize(Queue *qp)
{
	qp->front=-1;
	qp->rear=-1;	
}

void add(Queue *qp,int item)
{
	if(is_full(qp))
		printf("Queue Overflow");
	else
	{	
		if(qp->front == -1)
			qp->front=0;
		qp->elements[++qp->rear]=item;	
	}
	
}

int rem(Queue *qp)
{
	int x;
	if(is_empty())
		printf("Queue Underflow");
	else
	{
		if(qp->front>qp->rear)
			qp->front=qp->rear=-1;
			x=qp->elements[qp->front++];
	}
	
	return x;	
}

void display(Queue *qp)
{
	
		int i;
		for(i=qp->front;i<=qp->rear;i++)
		{
			printf("%d ",qp->elements[i]);	
		}	
	
}

int is_full(Queue *qp)
{
	if(qp->rear == SIZE-1)
		return 1;
	else
		return 0;
}

int is_empty(Queue *qp)
{
	if(qp->front == -1)
		return 1;
	else
		return 0;	
}

int main()
{
	Queue *qp;
	qp=(Queue*)malloc(sizeof(Queue));
	
	initialize(qp);
	
	add(qp,10);
	add(qp,20);
	add(qp,30);
	add(qp,40);
	add(qp,50);
	add(qp,60);
	
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);


	printf("\n");
	rem(qp);
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);	
	
	printf("\n");
	rem(qp);
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);
	
	printf("\n");
	rem(qp);
	display(qp);
}

==========================================================================

18

#include<stdio.h>
#include<stdlib.h>
#define SIZE 10

typedef struct st
{
	int top;
	char name[10][10];	
}stack;

// Initiazation of stack, top = -1

void initialize(stack *sp)
{
	sp->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void push(stack *sp,char *name)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			strcpy(sp->name[++sp->top],name);
}

// Delete an element from the stack / POP operation

char* pop(stack *sp)
{
	char* x;
	if(sp->top == -1)
		printf("\nStack underflow");
	else
		x=sp->name[sp->top--];
	return x;	
}


void display(stack *sp)
{
	int i;
	
	for(i=sp->top;i!=-1;i--)
	{
		printf("%s\n",*(sp->name+i));	
	}	
}

int main()
{
	stack s1;
	
	initialize(&s1);
	push(&s1,"Ajay");
	push(&s1,"Amit");
	push(&s1,"Rohit");
	
	display(&s1);
	
	printf("\n");
	char*p=pop(&s1);
	printf("Deleted name is : %s\n",p);
	display(&s1);
}

=============================================================================

19

#include<stdio.h>
#include<stdlib.h>
#define SIZE 26
#include "mystack.h"

int main()
{
	stack s1;
	
	initialize(&s1);
	
	int i;
	
	for(i=65;i<=90;i++)
	{
		push(&s1,i);
	}
	
	display(&s1);
}

==============================================================================

20

#include<stdio.h>

// Creation of a node & display the node value

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

int main()
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=500;
	np->next=NULL;
	
	printf("value : %d",np->data);
	
	free(np);	// Deallocating dynamic memory for node pointer
}

===============================================================================

21

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{
	
	node *p;	
	
	p=createNode(20);   // p = np
	
	printf("data : %d",p->data);
	printf("\nnext : %d",p->next);
	
	free(p);	// Deallocating dynamic memory for node pointer
}

==================================================================================

22

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{	
	node *p,*head,*tail,*ptr;	
	
	head=createNode(60);    // creation of first node
	tail=head;
	ptr=head;
	printf("%d ",ptr->data);  // ptr is priniting data value
	
	p=createNode(75);       // creation of second node
	
	tail->next=p;     // Attaching next node to previuous node   
    tail=tail->next;
    //ptr=tail;
	ptr=ptr->next;
	printf("%d ",ptr->data);
 	
    p=createNode(150);      // creation of third node
    
	tail->next=p;      // Attaching next node to previuous node   
	tail=tail->next;
	//ptr=tail;
	ptr=ptr->next;
	printf("%d ",ptr->data);
	
}

============================================================================

23

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{	
	node *p,*head,*tail,*ptr;	
	
	head=createNode(60);    // creation of first node
	tail=head;
	p=createNode(75);       // creation of second node
	
	tail->next=p;     // Attaching next node to previuous node   
    tail=tail->next;
   
    p=createNode(150);      // creation of third node
    
	tail->next=p;      // Attaching next node to previuous node   
	tail=tail->next;
	
	ptr=head;
	
	// accessing of node value using while loop
	while(ptr!=NULL)
	{
		printf("%d\t",ptr->data);
		ptr=ptr->next;
	}

}

====================================================================

24

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	double data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;


void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

node* createNode(double no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}


void insertAtTail(List *lp,double x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}

List* createList(int size)
{
	List *lp;
	lp=(List*)malloc(sizeof(List));
		initialize(lp);
	int i;
	double x;
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%lf",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

void traverse(List *lp)
{
	node *p;
	p=lp->head;
	int c=0;
	double sum=0.0,avg;
	printf("List is : ");
	
	while(p!=NULL)
	{
		printf("%.2lf ",p->data);
		sum=sum+(p->data);
		p=p->next;
		c++;	
	}	
	avg=sum/c;
	printf("\nAverage : %.2lf",avg);
}

int getNodeCount(List *lp)
{
	node *p;
	
	int count=0;
	
	for(p=lp->head;p!=NULL;p=p->next)
	{
		++count;	
	}	
	return count;
}

int main()
{	
	List *lp;
	int x;
	
	lp=createList(5);
	traverse(lp);
	
	
}

====================================================================

25

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;


void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}


void insertAtTail(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}

List* createList(int size)
{
	List *lp;
	lp=(List*)malloc(sizeof(List));
		initialize(lp);
	int i;
	int x;
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%d",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

void traverse(List *lp)
{
	node *p;
	p=lp->head;
	printf("List is : ");
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;	
	}	
}

int getNodeCount(List *lp)
{
	node *p;
	
	int count=0;
	
	for(p=lp->head;p!=NULL;p=p->next)
	{
		++count;	
	}	
	return count;
}

int main()
{	
	List *lp;
	int x;
	
	lp=createList(5);
	traverse(lp);
	
	int count=getNodeCount(lp);
	
	printf("\nTotal nodes : %d",count);	

}

=============================================================

26

// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;

// Initialization of Head and Tail pointer to NULL
void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

// Creating a node of Linked list
node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

// Inserting a node at the end of list
void insertAtTail(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}


void insertAtHead(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->tail=np;
	else
		np->next=lp->head;
	lp->head= np;
	
}
// Creating a list of specified size
List* createList()   // Creating a list of a specific size
{
	List *lp;
	int i,x,size;
	
	lp=(List*)malloc(sizeof(List));
	initialize(lp);
		
	printf("Enter no of elements : ");
	scanf("%d",&size);
	
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%d",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

// To display list elements
void traverse(List *lp)
{
	node *p;
	p=lp->head;
	printf("List is : ");
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;	
	}	
}


#include<stdio.h>
#include<stdlib.h>
#include "mylinklist.h"

int main()
{	
	List *lp;         // lp is List pointer 
	
	// Step-1 : Link list Creation
	lp=createList();  // lp will point to the created list
	
	// Step-2 : Displaying the List
	traverse(lp);  
	
	printf("\n");
	
	int item;
	printf("\nEnter node to add at head :");
	scanf("%d",&item);
	
	insertAtHead(lp,item);   
	//insertAtHead(lp,400);   
	traverse(lp); 
}

====================================================================

27

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;                // Data part
	struct nd *next;         // Pointer to next node
	struct nd *prev;         // Pointer to previous node
}node;
// Creating a node in the linked list

int main()
{	
	 node *head;
	 node *one=NULL;
	 node *two=NULL;
	 node *three=NULL;
	
	one=(node*)malloc(sizeof(node));    // data / next for node one
	two=(node*)malloc(sizeof(node));     // data / next for node two
	three=(node*)malloc(sizeof(node));   // data / next for node three
	
	one->data=10;
	two->data=20;
	three->data=30;
	
	one->next=two;
	one->prev=NULL;
	
	two->next=three;
	two->prev=one;
	
	three->next=NULL;
	three->prev=two;
	
	head=one;
	
	node *p;
	p=head;

	printf("Accessing in forward direction : ");
	/*
	printf("%d ",p->data);
	p=p->next;
	
	printf("%d ",p->data);
	p=p->next;
	
	printf("%d ",p->data);
	p=p->next;
	*/
	
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;
	}
	printf("\nAccessing in backward direction : ");
	
	/*
	p=three;
	printf("%d ",p->data);
	p=p->prev;
	
	printf("%d ",p->data);
	p=p->prev;
	
	printf("%d ",p->data);
	p=p->prev;
	*/
	p=three;
	
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->prev;
	}
}

===========================================================================

28

#include<stdio.h>
#include<stdlib.h>
#define SIZE 5

// Example of Stack to revrse a string
typedef struct st1
{
	int top;
	char elements[SIZE];	
}stack1;

typedef struct st2
{
	int top;
	char elements[SIZE];	
}stack2;

// Initiazation of stack, top = -1

void initialize(stack1 *sp1,stack2 *sp2)       // sp = &s1
{
	sp1->top=-1;
	sp2->top=-1;
}

// Add an element on the top of the stack / PUSH operation

void pushToStack1(stack1 *sp,char item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}


void pushToStack2(stack2 *sp,char item)
{
		if(sp->top == SIZE-1)	
			printf("\nStack overflow\n");
		else
			sp->elements[++sp->top]=item;
}
// Delete an element from the stack / POP operation

void copyToStack(stack1 *s1,stack2 *s2)
{
	int i;
	
	for(i=0;i<=s1->top;i++)
	{
		printf("%c ",s1->elements[i]);
		pushToStack2(s2,s1->elements[i]);	
	}	
}

void displayCopiedStack(stack2 *s)
{
	int i;
	for(i=0;i<=s->top;i++)
	{
		printf("%c ",s->elements[i]);	
	}	
}

int main()
{
	stack1 *s1;
	stack2 *s2;
	
	s1=(stack1*)malloc(sizeof(stack1));
	s2=(stack2*)malloc(sizeof(stack2));
	
	initialize(s1,s2);
		
	printf("==========================================\n");
	printf("Stack : 1 \n==============================\n");
	
	pushToStack1(s1,'A');
	pushToStack1(s1,'B');
	pushToStack1(s1,'C');
	pushToStack1(s1,'D');
		
	copyToStack(s1,s2);
	
	printf("\n========================================\n");
	printf("Stack : 2 \n==============================\n");
	displayCopiedStack(s2);
}


===============================================================================================

29

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}

int main()
{	
	 node *head;
	 node *one=NULL;
	 node *two=NULL;
	 node *three=NULL;
	
	one=(node*)malloc(sizeof(node));    // data / next for node one
	two=(node*)malloc(sizeof(node));     // data / next for node two
	three=(node*)malloc(sizeof(node));   // data / next for node three
	
	one->data=10;
	two->data=20;
	three->data=30;
	
	one->next=two;
	two->next=three;
	three->next=one;
	
	head=one;
	
	node *p;
	p=head;
	printf("%d ",p->data);
		p=p->next;
	while(p!=head)
	{
		printf("%d ",p->data);
		p=p->next;
	}
}

=========================================================================

30

#include<stdio.h>   
void main ()  
{  
    int a[10] = {10, 23, 40, 1, 2, 0, 14, 13, 50, 9};  
    int item, i,flag;  
    printf("\nEnter Item which is to be searched\n");  
    scanf("%d",&item);  
    for (i = 0; i< 10; i++)  
    {  
        if(a[i] == item)   
        {  
            flag = i+1;  
            break;  
        }   
        else   
        flag = 0;  
    }   
    if(flag != 0)  
    {  
        printf("\nItem %d found at location %d\n",item,flag);  
    }  
    else  
    {  
        printf("\nItem not found\n");   
    }  
}   

==================================================================

31 

#include<stdio.h>  
int binarySearch(int[], int, int, int);  
void main ()  
{  
    int arr[10] = {16, 19, 20, 23, 45};  
    int item, location=-1;   
    printf("Enter the item which you want to search ");  
    scanf("%d",&item);  
    location = binarySearch(arr, 0, 4, item);   // location=2  , beg =0 ,end =4 , item=19
    if(location != -1)   
    {  
        printf("Item found at location %d",location);  
    }  
    else  
    {  
        printf("Item not found");  
    }  
}   
int binarySearch(int a[], int beg, int end, int item)  // beg=0, end=4 , item=19 
{                                                      // beg=0, end=1, item =19
                                                       // beg=1, end=1, item=19
    int mid;  
    if(end >= beg)   
    {     
        mid = (beg + end)/2;  // mid=2, mid=0, mid=1
        if(a[mid] == item)    //
        {  
            return mid+1;     // mid=2
        }  
        else if(a[mid] < item)   
        {  
            return binarySearch(a,mid+1,end,item);  //   binarySearch(a,1,1,19);, loc = 2 returned
        }  
        else   
        {  
            return binarySearch(a,beg,mid-1,item);  //  binarySearch(a,0,1,19);
        }  
      
    }  
    return -1;   
}  

======================================================================

32

#include<stdio.h>  
// Bubble Sort

void main ()  
{  
    int i, j,temp;   
    int a[10] = { 10, 9, 7, 101, 23, 44, 12, 78, 34, 23};   
    for(i = 0; i<10; i++)  
    {  
        for(j = i+1; j<10; j++)  
        {  
            if(a[j] > a[i])  
            {  
                temp = a[i];  
                a[i] = a[j];  
                a[j] = temp;   
            }   
        }   
    }   
    printf("Printing Sorted Element List ...\n");  
    for(i = 0; i<10; i++)  
    {  
        printf("%d\n",a[i]);  
    }  
}  

========================================================================

33

#include<stdio.h>

typedef struct tr
{
	int data;
	struct tr *left;
	struct tr *right;
}tree;

tree* createnode(int value)
{
	tree *n;
	n=(tree*)malloc(sizeof(tree));

	n->data=value;
	n->left=NULL;
	n->right=NULL;
	
	return n;
}

int main()
{
	tree *root,*n1,*n2;
	
	root=createnode(100);
	
	n1=createnode(200);
	
	n2=createnode(300);
	
	root->left=n1;
	root->right=n2;
	
	root->left->left=createnode(400);
	root->left->right=createnode(500);
	
	printf("\t%d\n",root->data);
	printf("%d\t",root->left->data);
	printf("\t%d",root->right->data);
	printf("\t%d",root->left->left->data);
	printf("\t%d",root->left->right->data);
}

===============================================================

34

// Tree traversal in C

#include <stdio.h>
#include <stdlib.h>

struct node {
  int item;
  struct node* left;
  struct node* right;
};

// Inorder traversal
void inorderTraversal(struct node* root) {
  if (root == NULL) return;
  inorderTraversal(root->left);
  printf("%d ->", root->item);
  inorderTraversal(root->right);
}

// preorderTraversal traversal
void preorderTraversal(struct node* root) {
  if (root == NULL) return;
  printf("%d ", root->item);
  preorderTraversal(root->left);
  preorderTraversal(root->right);
}

// postorderTraversal traversal
void postorderTraversal(struct node* root) {
  if (root == NULL) return;
  postorderTraversal(root->left);
  postorderTraversal(root->right);
  printf("%d ", root->item);
}

// Create a new Node
struct node* createNode(value) {
  struct node* newNode = malloc(sizeof(struct node));
  newNode->item = value;
  newNode->left = NULL;
  newNode->right = NULL;

  return newNode;
}

// Insert on the left of the node
struct node* insertLeft(struct node* root, int value) {
  root->left = createNode(value);
  return root->left;
}

// Insert on the right of the node
struct node* insertRight(struct node* root, int value) {
  root->right = createNode(value);
  return root->right;
}

int main() {
  struct node* root = createNode(1);     // value 1 is assigned to root node
  insertLeft(root, 12);
  insertRight(root, 9);

  insertLeft(root->left, 5);
  insertRight(root->left, 6);
/*
  printf("Inorder traversal \n");
  inorderTraversal(root);
*/
  printf("\nPreorder traversal \n");
  preorderTraversal(root);
/*
  printf("\nPostorder traversal \n");
  postorderTraversal(root);
  */
}

===================================================================

35

#include<stdio.h>
#include<stdlib.h>
// Creation of a node ON DEFINING A FUNCTION TO CREATE A NODE

typedef struct nd            // Definition of the node 
{                            // members are data
	int data;
	struct nd *next;
}node;
// Creating a node in the linked list

typedef struct li
{
	node *head,*tail;	
}List;


void initialize(List *lp)
{
	lp->head=NULL;
	lp->tail=NULL;	
}

node* createNode(int no)
{
	node *np;
	
	np=(node*)malloc(sizeof(node));  // allocating dynamic memory to the node pointer
	
	if(np == NULL)
	{
		printf("Memory not available");
		exit(0);	
	}
	
	np->data=no;
	np->next=NULL;
	
	return np;
}


void insertAtTail(List *lp,int x)         // lp = lp, x =100
{
	node *np;
	
	np=createNode(x);     // Creating a node
	if(lp->head == NULL)
		lp->head=np;
	else
		lp->tail->next =np;
	lp->tail= np;
	
}

List* createList(int size)
{
	List *lp;
	lp=(List*)malloc(sizeof(List));
		initialize(lp);
	int i;
	int x;
	for(i=0;i<size;i++)
	{
		printf("Enter Item : ");
		scanf("%d",&x);
		insertAtTail(lp,x);
	}
	return lp;
}

void traverse(List *lp)
{
	node *p;
	int c=0;
	p=lp->head;
	printf("List is : ");
	while(p!=NULL)
	{
		printf("%d ",p->data);
		p=p->next;
		c++;
	}	
	
	int arr[c];
	p=lp->head;
	int i=c-1;
	while(p!=NULL)
	{
		arr[i]=p->data;
		p=p->next;
		i--;
	}
	
	printf("\nLinked List in reverse order : ");
	for(i=0;i<c;i++)
	{
		printf("%d ",arr[i]);
	}
			
}

node* search(List *lp,int x)
{
	node *p;
	
	p=lp->head;
	while(p!=NULL)
	{
		if(x == p->data)
			return p;
		p=p->next;	
	}	
}

int main()
{	
	List *lp;
	int x;
	
	lp=createList(5);
	traverse(lp);
}

=============================================================

36

#include<stdio.h>

int main()
{
	int ad[3][3];
	
	int age;
	
	int i,j;
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			if(i==0 && j==1)
			{
				printf("Enter age : ");
				scanf("%d",&age);
				ad[i][j]=age;
			}
			else if(i==1 && j==1)
			{
				printf("Enter age : ");
				scanf("%d",&age);
				ad[i][j]=age;
			}
			else if(i==1 && j==2)
			{
				printf("Enter age : ");
				scanf("%d",&age);
				ad[i][j]=age;
			}
			else
			{
				ad[i][j]=0;
			}
		}
	}
	
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			printf("%d\t",ad[i][j]);	
		}
		printf("\n");
	}
}

===============================================================================

37

#include<stdio.h>
#include<stdlib.h>
// Binary Search tree 
typedef struct st
{
	int key;
	struct st *left;
	struct st *right;
}node;

node* newnode(int data)
{
	node *t;
	t=(node*)malloc(sizeof(node));
	t->key=data;
	t->left=NULL;
	t->right=NULL;
	return t;
}

node* insert(node *nd,int data)
{
	if(nd==NULL)
		return newnode(data);
	
	if(data < nd->key)
		nd->left = insert(nd->left,data);
		
	else if(data > nd->key)
		nd->right = insert(nd->right,data);

	return nd;
}

void inorder(node* root)
{
	if( root == NULL)
		return;
	inorder(root->left);
	printf("%d ",root->key);
	inorder(root->right);
}

int main()
{
	node *root=NULL;
	
	int size;
	printf("Enter Tree size : ");
	scanf("%d",&size);
	
	int rt;
	printf("\nEnter root value :");
	scanf("%d",&rt);
	
	root=insert(root,rt);
	int i=0;
	int num;
	
	while(i<size-1)
	{
		    printf("Enter data : ");
			scanf("%d",&num);
			insert(root,num);	
			i++;	
	}
	inorder(root);
}

=================================================================================

38

#include <stdio.h>  
#include <stdlib.h>  
void push();  
void pop();  
void display();  
struct node   
{  
int val;  
struct node *next;  
};  
struct node *head;  
  
void main ()  
{  
    int choice=0;     
    printf("\n*********Stack operations using linked list*********\n");  
    printf("\n----------------------------------------------\n");  
    while(choice != 4)  
    {  
        printf("\n\nChose one from the below options...\n");  
        printf("\n1.Push\n2.Pop\n3.Show\n4.Exit");  
        printf("\n Enter your choice \n");        
        scanf("%d",&choice);  
        switch(choice)  
        {  
            case 1:  
            {   
                push();  
                break;  
            }  
            case 2:  
            {  
                pop();  
                break;  
            }  
            case 3:  
            {  
                display();  
                break;  
            }  
            case 4:   
            {  
                printf("Exiting....");  
                break;   
            }  
            default:  
            {  
                printf("Please Enter valid choice ");  
            }   
    }
}  
}  
void push ()  
{  
    int val;  
    struct node *ptr = (struct node*)malloc(sizeof(struct node));   
    if(ptr == NULL)  
    {  
        printf("not able to push the element");   
    }  
    else   
    {  
        printf("Enter the value");  
        scanf("%d",&val);  
        if(head==NULL)  
        {         
            ptr->val = val;  
            ptr -> next = NULL;  
            head=ptr;  
        }   
        else   
        {  
            ptr->val = val;  
            ptr->next = head;  
            head=ptr;  
               
        }  
        printf("Item pushed");  
          
    }  
}  
  
void pop()  
{  
    int item;  
    struct node *ptr;  
    if (head == NULL)  
    {  
        printf("Underflow");  
    }  
    else  
    {  
        item = head->val;  
        ptr = head;  
        head = head->next;  
        free(ptr);  
        printf("Item popped %d",item);  
          
    }  
}  
void display()  
{  
    int i;  
    struct node *ptr;  
    ptr=head;  
    if(ptr == NULL)  
    {  
        printf("Stack is empty\n");  
    }  
    else  
    {  
        printf("Printing Stack elements \n");  
        while(ptr!=NULL)  
        {  
            printf("%d\n",ptr->val);  
            ptr = ptr->next;  
        }  
    }  
}  

============================================================================

39

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define SIZE 100

typedef struct {
	double item[SIZE];
	int top;
}OperandStack;

// function prototypes

// function for stack operations
void push(OperandStack *, double);
double pop(OperandStack *);
int isEmpty(OperandStack *);


// push operation
void push(OperandStack *sp, double v){
	// checking overflow
	if (sp->top == SIZE-1){
		printf("Stack overflow, terminating program\n");
		exit(1);
	}
	// otherwise push
	sp->item[++sp->top] = v;		
}
// Pop operation
double pop(OperandStack *sp){
	if (isEmpty(sp)){
		printf("Stack underflow, terminating program\n");
		exit(1);
	}	
	return sp->item[sp->top--];
}

// returns 1 if the stack is empty, 0 otherwise
int isEmpty(OperandStack *sp){
	return sp->top == -1;
}

double operate(double leftOpnd, double rightOpnd, char opr){
	double result = 0.0;
	switch(opr){
		case '+': result = leftOpnd + rightOpnd;
				  break;
		case '-': result = leftOpnd - rightOpnd;
				  break;		 
		case '*': result = leftOpnd * rightOpnd;
				  break;		 		
		case '/': result = leftOpnd / rightOpnd;
				  break;		 
		case '$': result = pow(leftOpnd, rightOpnd);
				  break;		 			
		default: printf("%c is not a valid operator\n", opr);
				 exit(1);		  			     
		
	}
	
	
	return result;
}

double evalPostfix(char postfix[]){         // postfix[] = 24+
	OperandStack stack;
	stack.top = -1;
	int i = 0;
	while(postfix[i] != '\0'){
		char token = postfix[i];
		if (token >= '0' && token <= '9'){    // '2' >= '0'  ==>  50 >= 48, 50 <= 57
			int v = token - '0';              // converted in integer , v=2
			push(&stack, (double)v);
		}
		else if (token == '+' || token == '-' || token == '*' || token == '/' || token == '$'){
			double opnd1 = pop(&stack);     // opnd1 =4
			double opnd2 = pop(&stack);     // opnd2 =2
			double result = operate(opnd2, opnd1, token);   // 2,4,+ will return 6.0000
			push(&stack, result);
		}
		else{
			printf("Invalid symbol encountered\n");
			exit(1);
		}
		++i;
	}
	return pop(&stack);
	
}

int main(){
	char postfix[SIZE];
	printf("Input postfix expression: ");
	scanf("%s", postfix);                          // 24+ >>>>> 2+4
	
	double result = evalPostfix(postfix);       // postfix[] = "24+"
	printf("Result: %lf\n", result);            // 6
	return 0;
	

}


=================================================================================

40 

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct Node{
  int data;
  struct Node *next;
}Node;

typedef struct {
  struct Node *head;
  struct Node *tail;
  int nodeCount;
}LinkedList;

// to initialize the linkedlist object
// Input parameter: listp is the pointer to linkedlist object
// Precondition: LinkedList object pointed by listptr must be existing.
// Return Value: Nothing
void initList(LinkedList *lstPtr){
  lstPtr->head = NULL;
  lstPtr->tail = NULL;
  lstPtr->nodeCount = 0;
}



// To add a new node at the end of the LinkedList
// Input parameters: pointer to struct LinkedList, an integer data that will
//                   be the content  of the new node.
// Precondition: The linkedList object must be existing.
// Return Value: Nothing
void insertAtTail(LinkedList *listPtr, int data){
  Node *newNodePtr = (Node*)malloc(sizeof(Node));
  if (newNodePtr == NULL){
    printf("Unable to allocate new node\n");
    return;
  }
  newNodePtr->data = data;
  newNodePtr->next = NULL;


  if (listPtr->head == NULL){
    // this is the case when the list is empty
    listPtr->head = newNodePtr;
    listPtr->tail = newNodePtr;
  }
  else{
    // this is the case when the list is not empty
    listPtr->tail->next = newNodePtr;
    listPtr->tail = newNodePtr;
  }
  listPtr->nodeCount++;
}

void printList(LinkedList *lstPtr){
 
  Node *current = lstPtr->head;
  while(current != NULL){
    printf("%d ", current->data);
    current = current->next;
  }

}


void reverse(LinkedList *lstPtr){
  // declaring 3 Node pointers for doing the reversal
  Node *p, *q, *r;
  // p is current node, q is just previous to p and r is just immediate next to p
  q = NULL;
  p = lstPtr->head;
  r = p->next;
  while(1){
    // reverse the link
    p->next = q;
    if (p == lstPtr->tail)
      break;
    // shift the pointers towards right
    q = p;
    p = r;
    r = r->next;
  }
  lstPtr->tail = lstPtr->head;
  lstPtr->head = p;
}

int main(){
  LinkedList list;
  initList(&list);
  
  insertAtTail(&list, 20);
  insertAtTail(&list, 30);
  insertAtTail(&list, 50);
  insertAtTail(&list, 60);
  insertAtTail(&list, 80);
  
  printList(&list);

            reverse(&list);

  printf("\n");
  printList(&list);

  return 0;
}

=======================================================================

41

#include<stdio.h>  
// Bubble Sort

int binarySearch(int a[], int beg, int end, int item)  // beg=0, end=4 , item=19 
{                                                      // beg=0, end=1, item =19
       
	                                               // beg=1, end=1, item=19
    int mid;  
    if(end >= beg)   
    {     
        mid = (beg + end)/2;  // mid=2, mid=0, mid=1
        if(a[mid] == item)    //
        {  
            return mid+1;     // mid=2
        }  
        else if(a[mid] > item)   
        {  
            return binarySearch(a,mid+1,end,item);  //   binarySearch(a,1,1,19);, loc = 2 returned
        }  
        else   
        {  
            return binarySearch(a,beg,mid-1,item);  //  binarySearch(a,0,1,19);
        }  
      
    }  
    return -1;   
} 

void main ()  
{  
    int i, j,temp;   
    int a[10] = { 10, 9, 7, 101, 23};   
    for(i = 0; i<5; i++)  
    {  
        for(j = i+1; j<5; j++)  
        {  
            if(a[j] > a[i])  
            {  
                temp = a[i];  
                a[i] = a[j];  
                a[j] = temp;   
            }   
        }   
    }   
    printf("Printing Sorted Element List ...\n");  
    for(i = 0; i<5; i++)  
    {  
        printf("%d\n",a[i]);  
    }  
    
     int item, location=-1;   
    printf("Enter the item which you want to search ");  
    scanf("%d",&item);  
    location = binarySearch(a, 0, 4, item);   // location=2  , beg =0 ,end =4 , item=19
   
    if(location != -1)   
    {  
        printf("\nItem found at location %d",location);  
    }  
    else  
    {  
        printf("\nItem not found");  
    }  
}  

